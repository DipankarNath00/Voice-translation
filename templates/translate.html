{% extends 'base.html' %}

{% block title %}{{ title }}{% endblock %}

{% block content %}
<div class="container mt-4">
    <h2 class="mb-4 text-center"><i class="bi bi-mic me-2"></i>Voice Translator</h2>

    <div class="card p-4 mb-4 shadow-sm">
        <form method="POST" action="{{ url_for('upload_translate') }}" enctype="multipart/form-data" id="translateForm">
            {{ form.hidden_tag() }}
            <div class="row g-3 align-items-end">
                {# Source Language Selection #}
                <div class="col-md-5">
                    {{ form.source_language.label(class="form-label") }}
                    {{ form.source_language(class="form-select form-select-sm") }}
                </div>
                {# Target Language Selection (Multi-Select) #}
                <div class="col-md-5">
                    {{ form.target_languages.label(class="form-label") }}
                    {{ form.target_languages(class="form-select form-select-sm", multiple="multiple") }}
                </div>
                <div class="col-md-2">
                    <button type="button" id="recordButton" class="btn btn-danger w-100 btn-sm">
                        <i class="bi bi-mic-fill me-1"></i><span>Start Recording</span>
                    </button>
                </div>
            </div>

            <!-- Military Mode Section -->
            <div class="mt-4">
                <div class="form-check mb-3">
                    <input class="form-check-input" type="checkbox" id="militaryMode">
                    <label class="form-check-label" for="militaryMode">
                        <i class="bi bi-shield-lock me-1"></i>Military Mode
                    </label>
                </div>
                
                <!-- Encryption Key Field -->
                <div class="mb-3">
                    <label for="encKey" class="form-label">Encryption Key</label>
                    <input type="text" class="form-control" id="encKey" name="encKey" style="display: none;"
                           placeholder="Paste Fernet key here (e.g., g95WUai_wFPOlp2D9CdnmVnhfDB4sNKpy0VHhCWYG6I=)">
                    <small class="form-text text-muted">Enter the same key in both fields</small>
                </div>

                <!-- Decryption Key Field -->
                <div class="mb-3">
                    <label for="decKey" class="form-label">Decryption Key</label>
                    <input type="text" class="form-control" id="decKey" name="decKey" style="display: none;"
                           placeholder="Must match Encryption Key">
                </div>

                <!-- Info Alert -->
                <div class="alert alert-info" role="alert" style="display: none;" id="militaryModeInfo">
                    <i class="bi bi-info-circle me-1"></i>
                    When Military Mode is activated, an email notification will be sent with your location information.
                </div>
            </div>

            {{ form.submit(class="btn btn-primary mt-3 d-none") }}
        </form>
    </div>

    <!-- Status and Error Messages -->
    <div id="status" class="alert alert-info d-none align-items-center" role="alert">
        <div class="spinner-border spinner-border-sm me-2 d-none" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <span class="status-text">Status message here</span>
        <span class="recording-indicator ms-auto d-none"></span>
    </div>

    <div id="error" class="alert alert-danger d-none" role="alert">
        <span class="error-text"></span>
    </div>

    <!-- Results Section -->
    <div id="results" class="mt-4 d-none">
        <div class="card">
            <div class="card-body">
                <h5 class="card-title">Translation Results</h5>
                <p class="mb-2">
                    <strong>Detected Source Language:</strong>
                    <span id="detectedSourceLanguage" class="badge bg-secondary">Not detected</span>
                </p>
                <p class="mb-2">
                    <strong>Original Text:</strong>
                    <span id="originalText" class="text-muted">No text detected</span>
                </p>
                <div id="multiResultsContainer"></div>
            </div>
        </div>
    </div>
</div>

<style>
:root {
    /* ... existing vars ... */
    --military-field-border: #ccc;
}

body.dark-mode {
    /* ... existing dark mode vars ... */
    --military-field-border: #555;
}

/* Styles for the key input fields */
input[type="text"][id$="Key"] {
    padding: 10px;
    margin: 5px 0;
    width: 100%;
    font-size: 16px;
    border-radius: 5px;
    border: 1px solid var(--military-field-border);
    background-color: var(--container-bg);
    color: var(--text-color);
    display: none;
}

#keyHint {
    font-size: 0.9em;
    color: var(--text-color);
    text-align: center;
    display: block;
    margin-top: 5px;
    margin-bottom: 15px;
}

/* Military Mode specific styles */
#encKey, #decKey {
    font-family: monospace;
    font-size: 0.9rem;
    padding: 0.5rem;
    width: 100%;
    margin-bottom: 10px;
    border: 1px solid #ced4da;
    border-radius: 0.25rem;
}

.form-check-label {
    font-weight: 500;
    cursor: pointer;
}

.form-check-input {
    cursor: pointer;
}

.bg-light {
    background-color: var(--bs-light) !important;
}

body.dark-mode .bg-light {
    background-color: var(--bs-dark) !important;
}
</style>

<script>
    const recordButton = document.getElementById('recordButton');
    const recordButtonIcon = recordButton.querySelector('i');
    const recordButtonText = recordButton.querySelector('span');
    const targetLanguageSelect = document.getElementById('target_languages');
    const sourceLanguageSelect = document.getElementById('source_language');
    const statusDiv = document.getElementById('status');
    const statusSpinner = statusDiv.querySelector('.spinner-border');
    const statusText = statusDiv.querySelector('.status-text');
    const recordingIndicator = statusDiv.querySelector('.recording-indicator');
    const errorDiv = document.getElementById('error');
    const errorText = errorDiv.querySelector('.error-text');
    const resultsDiv = document.getElementById('results');
    const detectedSourceLanguageSpan = document.getElementById('detectedSourceLanguage');
    const originalTextSpan = document.getElementById('originalText');
    const multiResultsContainer = document.getElementById('multiResultsContainer');
    const translateForm = document.getElementById('translateForm');

    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    let stream;

    async function startRecording() {
        console.log("startRecording function called");
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            showError("Your browser does not support audio recording.");
            return;
        }
        resetUIState(true); // Reset UI before starting
        try {
            console.log("Attempting to get user media...");
            stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            console.log("Successfully got user media stream.");
            
            console.log("Attempting to create MediaRecorder...");
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            console.log("Successfully created MediaRecorder.");

            mediaRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = async () => {
                statusSpinner.classList.remove('d-none');
                recordingIndicator.classList.add('d-none');
                showStatus("Processing recording...");
                const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
                audioChunks = [];
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
                await uploadAudio(audioBlob);
            };

            mediaRecorder.onerror = (event) => {
                console.error("MediaRecorder error:", event.error);
                showError(`Recording error: ${event.error.name || 'Unknown error'}`);
                stopStream();
                resetUIState();
            };

            mediaRecorder.start();
            isRecording = true;
            recordButton.classList.remove('btn-danger');
            recordButton.classList.add('btn-warning');
            recordButtonIcon.classList.remove('bi-mic-fill');
            recordButtonIcon.classList.add('bi-stop-circle-fill');
            recordButtonText.textContent = 'Stop Recording';
            showStatus("Recording started...");
            recordingIndicator.classList.remove('d-none');
            errorDiv.classList.add('d-none');
            resultsDiv.classList.add('d-none');

        } catch (err) {
            console.error("Error in startRecording:", err);
            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                showError("Microphone access denied. Please allow permission in your browser settings.");
            } else {
                showError(`Could not access microphone: ${err.name || err.message}.`);
            }
            resetUIState();
        }
    }

    function stopStream() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
            console.log("Media stream stopped.");
        }
    }

    function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            recordingIndicator.classList.add('d-none');
            console.log("Recording stopped by user.");
        }
        stopStream();
    }

    async function uploadAudio(audioBlob) {
        if (audioBlob.size === 0) {
            showError("Cannot process empty recording.");
            resetUIState();
            return;
        }

        // Validate military mode keys before proceeding
        if (!validateKeys()) {
            return;
        }

        const formData = new FormData(translateForm);
        formData.append('audio_file', audioBlob, 'recording.webm');
        
        // Add military mode data
        formData.append('military', militaryModeCheckbox.checked);
        if (militaryModeCheckbox.checked) {
            formData.append('encKey', encKeyInput.value);
            formData.append('decKey', decKeyInput.value);
        }

        showStatus("Uploading and processing...", true);
        recordButton.disabled = true;

        try {
            const response = await fetch("{{ url_for('upload_translate') }}", {
                method: 'POST',
                body: formData
            });

            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                showError("Server returned invalid response format");
                resetUIState();
                return;
            }

            const data = await response.json();
            if (!response.ok) {
                throw new Error(data.error || `Server error: ${response.status}`);
            }
            
            showStatus(data.message || 'Processing complete!', false, 'success');
            
            // Update UI with results
            detectedSourceLanguageSpan.textContent = data.detected_source_language || 'N/A';
            detectedSourceLanguageSpan.classList.remove('bg-secondary');
            detectedSourceLanguageSpan.classList.add('bg-info');
            originalTextSpan.textContent = data.original_text;
            originalTextSpan.classList.remove('text-muted');
            
            // Clear and update multi-results
            multiResultsContainer.innerHTML = '';
            if (data.results && data.results.length > 0) {
                data.results.forEach(result => {
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'mt-3';
                    resultDiv.innerHTML = `
                        <h6>${result.target_lang}</h6>
                        <p class="mb-2">${result.translated_text}</p>
                        ${result.audio_filename ? `
                            <audio controls class="w-100">
                                <source src="{{ url_for('play', filename='') }}${result.audio_filename}" type="audio/mpeg">
                                Your browser does not support the audio element.
                            </audio>
                        ` : ''}
                    `;
                    multiResultsContainer.appendChild(resultDiv);
                });
            } else {
                multiResultsContainer.innerHTML = '<p class="text-muted">No translations were generated.</p>';
            }
            
            resultsDiv.classList.remove('d-none');
            recordButton.disabled = false;

        } catch (error) {
            console.error('Processing Error:', error);
            showError(`Processing failed: ${error.message}`);
            resetUIState();
        }
    }

    function showStatus(message, showSpinner = false, type = 'info') {
        statusText.textContent = message;
        statusDiv.className = `alert alert-${type} d-flex align-items-center`;
        statusDiv.classList.remove('d-none');
        errorDiv.classList.add('d-none');
        if (showSpinner) {
            statusSpinner.classList.remove('d-none');
        } else {
            statusSpinner.classList.add('d-none');
        }
        if (type === 'info' && message.toLowerCase().includes('recording')) {
            recordingIndicator.classList.remove('d-none');
        } else {
            recordingIndicator.classList.add('d-none');
        }
    }

    function showError(message) {
        errorText.textContent = message;
        errorDiv.classList.remove('d-none');
        statusDiv.classList.add('d-none');
    }

    function resetUIState(keepRecording = false) {
        if (!keepRecording) {
            isRecording = false;
            recordButton.classList.remove('btn-warning');
            recordButton.classList.add('btn-danger');
            recordButtonIcon.classList.remove('bi-stop-circle-fill');
            recordButtonIcon.classList.add('bi-mic-fill');
            recordButtonText.textContent = 'Start Recording';
        }
        recordButton.disabled = false;
        statusSpinner.classList.add('d-none');
        recordingIndicator.classList.add('d-none');
    }

    // Event Listeners
    recordButton.addEventListener('click', () => {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    });

    // Military Mode Elements
    const militaryModeCheckbox = document.getElementById('militaryMode');
    const encKeyInput = document.getElementById('encKey');
    const decKeyInput = document.getElementById('decKey');
    const militaryModeInfo = document.getElementById('militaryModeInfo');

    function updateKeyInputVisibility() {
        const isVisible = militaryModeCheckbox.checked;
        encKeyInput.style.display = isVisible ? 'block' : 'none';
        decKeyInput.style.display = isVisible ? 'block' : 'none';
        militaryModeInfo.style.display = isVisible ? 'block' : 'none';
        
        if (!isVisible) {
            encKeyInput.value = '';
            decKeyInput.value = '';
        }
    }

    // Initial call to set correct state on page load
    document.addEventListener('DOMContentLoaded', function() {
        updateKeyInputVisibility();
        console.log('Military Mode fields visibility updated');
    });

    // Event listener for checkbox change
    militaryModeCheckbox.addEventListener('change', function() {
        console.log('Military Mode checkbox changed:', this.checked);
        updateKeyInputVisibility();
    });

    // Add key validation
    function validateKeys() {
        if (militaryModeCheckbox.checked) {
            if (!encKeyInput.value || !decKeyInput.value) {
                showError("Both encryption and decryption keys are required for Military Mode.");
                return false;
            }
            if (encKeyInput.value !== decKeyInput.value) {
                showError("Encryption and decryption keys must match.");
                return false;
            }
        }
        return true;
    }
</script>
{% endblock %}
